{
  "version": 3,
  "sources": ["../../src/hof.ts", "../../src/esbuild-wrapper/hof.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\n\r\ninterface PropertyMap {\r\n    [propertyName: string]: Object & Partial<{ bind(thisArg: Object, ...args: Object[]): Object }>\r\n}\r\n\r\ninterface BindVariableExpressionsMap {\r\n    [bindVariableName: string]: string[]\r\n}\r\n\r\ninterface ObjectObservable {\r\n    lastActionMethod: string;\r\n    lastActionIndex: number;\r\n    lastActionPropertyPath: string;\r\n\r\n    _observers: Map<HofHtmlElement, string[]>;\r\n}\r\n\r\ninterface ArrayObservable<T> extends ObjectObservable { \r\n    _emit: (index: number, items: T[]) => Array<T>;\r\n\r\n    edit: (index: number, element: T) => T[];\r\n    delete: (index: number) => T[];\r\n}\r\n\r\n// Extend Object and Array<T> within the framework (not global, because extensions \r\n// are only usable within the context of an HofHtmlElement).\r\ntype Object = globalThis.Object & Partial<ObjectObservable>;\r\ntype Array<T> = globalThis.Array<T> & Partial<ArrayObservable<T>>;\r\n\r\ntype DOMElement = HTMLElement | Text | Node | HofHtmlElement;\r\n\r\ntype TemplateStringFunction = (listItemParameter?: Object) => string;\r\n\r\nclass AttributeExpression {\r\n    public constructor(public execute: Function,\r\n        public bindVariableNames: string[], public template: string) {}\r\n}\r\n\r\n// Base class for all Web components created by this framework\r\nexport abstract class HofHtmlElement extends HTMLElement  {\r\n  _tagName: string;\r\n  _root: HTMLElement;\r\n  _shadow: ShadowRoot;\r\n\r\n  _observersForBindVariable: Map<string, Map<DOMElement, string[]>> = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n  _observerExpressions: Map<DOMElement, Map<string, AttributeExpression>> = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n\r\n  _properties: PropertyMap = {}; // Global properties (of component)\r\n  _locals: PropertyMap = {}; // Local variables (of render function), including list iteration variables such as person0, person1, ...\r\n  \r\n  _allBindVariables: PropertyMap = null;\r\n  _allBindExpressions: BindVariableExpressionsMap = {};\r\n\r\n  _renderIteration: number = -1;\r\n\r\n  _listTemplate: TemplateStringFunction = null;\r\n  _listData: Object[] = [];\r\n  _listIt: string = \"\";\r\n  _listStart: number = 0;\r\n\r\n  PROPS_FILTER = (p: string) => p.charAt(0) != '_' && p != p.toUpperCase() && p != 'constructor' && p != 'render';\r\n  \r\n  REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+)', 'g');\r\n  DERIVED_PROPERTY_SIGNATURE_REGEX = new RegExp(\"^function *\\\\(\\\\)\");\r\n\r\n  constructor(tagName: string = 'div') {\r\n      super();\r\n      this._tagName = tagName;\r\n      this._shadow = this.attachShadow({ mode: \"open\" });\r\n  }\r\n\r\n  connectedCallback() {\r\n      this._root = document.createElement(this._tagName);\r\n      this._shadow.appendChild(this._root);\r\n\r\n      this.render();\r\n  }\r\n\r\n  abstract render(): void;\r\n\r\n  useAutoProps() {\r\n      // Replace all public simple properties with getters and setters,\r\n      // so that access can be intercepted and observability can be realized\r\n      this._forEachPropertyOfObjectAndPrototype((prop, obj) => {\r\n          const initialValue = obj[prop];\r\n\r\n          // Fix for event handlers because they cannot be added with defineProperty\r\n          // from component() as long as a web component is not part of the DOM\r\n          if (prop.startsWith(\"event-\")) {\r\n              prop = prop.substring(6)\r\n              delete obj[prop];\r\n          }\r\n\r\n          if (prop == \"construct\" && typeof(initialValue) == \"function\") {\r\n              initialValue.call(this);\r\n          }\r\n          else // Default Property handling\r\n              Object.defineProperty(this, prop, {\r\n                  get: function() { return this.getProperty(prop, initialValue); },\r\n                  set: function(v) {\r\n                      const oldValue = this.getProperty(prop, initialValue);\r\n\r\n                      if (this._callBindVariableBeforeChangedHook(this, prop, v, oldValue)) {\r\n                        this.setProperty(prop, v);                        \r\n                        this._callBindVariableAfterChangedHook(this, prop, v, oldValue);\r\n                      }\r\n                    },\r\n                  enumerable: true,\r\n                  configurable: true\r\n              });\r\n      })\r\n  }\r\n\r\n  setProperty(name: string, value: Object) {\r\n      const oldValue = this._properties[name];\r\n\r\n      // Render again in case of complex object or on value change of simple property or on collection action\r\n      if (typeof(oldValue) == \"object\" || typeof(value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n          // Process initial element-property setter calls (cache for time after template\r\n          // has been constructed and further binding variables are available)\r\n          this._properties[name] = value;\r\n\r\n          // Update properties including local binding variables\r\n          if (this._allBindVariables)\r\n              this._allBindVariables[name] = value;\r\n\r\n          this._updatePropertyObservers([name, value]);\r\n      }\r\n\r\n      // Make new objects observable\r\n      if (this._allBindVariables)\r\n          this._makeBindVariableObservable(name);\r\n  }\r\n\r\n  getProperty(name: string, initialValue: Object): Object {\r\n      if (this._allBindVariables)\r\n          return this._allBindVariables[name];\r\n\r\n      return this._properties[name] ?? this.getAttribute(name) as Object ?? initialValue;\r\n  }\r\n\r\n  _hasAlreadyRendered() {\r\n      return this._root.textContent != \"\";\r\n  }\r\n\r\n  renderContent(html: TemplateStringFunction, locals: PropertyMap = undefined) {\r\n      this._renderFull(html, locals);\r\n  }\r\n\r\n  renderList(data: Object[]|string, html: TemplateStringFunction, locals: PropertyMap = undefined) {\r\n      const expression = html.toString();\r\n      const listIt = expression.substring(expression.indexOf('(')+1, expression.indexOf(')'));\r\n\r\n      // Liste zum Zeitpunkt des Aufrufs noch nicht aufgel\u00F6st (first rendering), d.h. noch Wert wie ${data}\r\n      if (typeof data == \"string\") return;\r\n\r\n      this._listData = data;\r\n      this._listIt = listIt;\r\n      this._listTemplate = html;\r\n      this._listStart = this._root.childNodes.length;\r\n\r\n      if (typeof(locals) == \"undefined\" || locals == null)\r\n          locals = {};\r\n\r\n      for (const listItem of this._listData) {\r\n          locals[this._listIt] = listItem;\r\n          this._renderFull(html, locals);\r\n      }\r\n  }\r\n\r\n  _calculateProperties() {\r\n      let result = {};\r\n      this._forEachPropertyOfObjectAndPrototype((prop, obj) => result[prop] = obj[prop]);\r\n\r\n      this._allBindVariables = result;\r\n  }\r\n\r\n  _forEachPropertyOfObjectAndPrototype(func: (prop: string, obj: Object) => void) {\r\n      for (const name of Object.getOwnPropertyNames(this).filter(this.PROPS_FILTER))\r\n          func(name, this);\r\n\r\n      const prototype = Object.getPrototypeOf(this);\r\n      for (const name of Object.getOwnPropertyNames(prototype).filter(this.PROPS_FILTER))\r\n          func(name, prototype);\r\n  }\r\n\r\n  _convertToTemplateExpression(buildFunction: TemplateStringFunction) {\r\n      let expression = buildFunction.toString();\r\n      const expressionStart = expression.indexOf('`');\r\n\r\n      if (expressionStart > 0)\r\n          expression = expression.substring(expressionStart+1, expression.length-1);\r\n\r\n      return expression;\r\n  }\r\n\r\n  _parseHTML(htmlFunction: TemplateStringFunction, locals: PropertyMap): [NodeListOf<ChildNode>, PropertyMap, string[]] {\r\n      const html = this._convertToTemplateExpression(htmlFunction);\r\n\r\n      // First call of render?\r\n      if (this._allBindVariables == null)\r\n          this._calculateProperties();\r\n\r\n      const allBindVariables = this._allBindVariables;\r\n      const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n\r\n      this._calculateBindings(template, bindVariableNames);\r\n\r\n      const parser = new DOMParser();\r\n      const elements = parser.parseFromString(template, \"text/html\").body.childNodes;\r\n\r\n      return [elements, allBindVariables, bindVariableNames];\r\n  }\r\n\r\n  _makeBindVariableObservable(bindVariableName: string) {\r\n      for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n          this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n  }\r\n\r\n  _makeBindVariableStructureObservable(bindVariableName: string, bindingExpression: string) {\r\n      const o = this._allBindVariables[bindVariableName];\r\n      const props = bindingExpression.split('.');\r\n\r\n      let propObj = o;\r\n      let propertyPath = bindVariableName;\r\n      for (let i=0; i<props.length; i++) {\r\n          let lastProp = props[i];\r\n          propertyPath += `.${props[i]}`;\r\n\r\n          if (typeof propObj == \"undefined\") return;\r\n\r\n          if (typeof propObj == 'object') {\r\n              if(!Array.isArray(propObj))\r\n                  this._makeObjectObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n              else\r\n                  this._makeArrayObservable(propObj, bindVariableName);\r\n          }\r\n\r\n          propObj = propObj[props[i]];\r\n      }\r\n  }\r\n\r\n  _callBindVariableBeforeChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}BeforeChanged`;\r\n    if (obj[hookMethodName]) {\r\n        const ret = obj[hookMethodName](newValue, oldValue);\r\n        if (typeof ret != \"undefined\" && ret == false)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _callBindVariableAfterChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}AfterChanged`;\r\n    if (obj[hookMethodName])\r\n        obj[hookMethodName](newValue, oldValue);\r\n  }\r\n\r\n  _callBindVariableBeforePropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}BeforePropertyChanged`;\r\n    if (obj[hookMethodName]) {\r\n        const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n        if (typeof ret != \"undefined\" && ret == false)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _callBindVariableAfterPropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}AfterPropertyChanged`;\r\n    if (obj[hookMethodName])\r\n        obj[hookMethodName](subProp, newValue, oldValue);\r\n  }\r\n\r\n  _makeObjectObservable(obj: Object, observerProperty: string, componentProperty: string, propertyPath: string) {\r\n      let _value = obj[observerProperty];\r\n\r\n      const self = this;\r\n\r\n      if (this._registerNewObserver(obj, observerProperty)) {\r\n        Object.defineProperty(obj, observerProperty, {\r\n            get: function() { return _value; }.bind(self),\r\n            set: function(v: Object) {\r\n                const _oldValue = _value;\r\n\r\n                if (self._callBindVariableBeforeChangedHook(obj, observerProperty, v, _oldValue)) {\r\n                    _value = v;\r\n\r\n                    obj._observers.forEach((properties, component) => properties.forEach(\r\n                        () => {\r\n                            let bindVariableValue = component.getProperty(componentProperty, undefined);\r\n                            if (bindVariableValue) {\r\n                                if (!component._callBindVariableBeforePropertyChangedHook(self, componentProperty, propertyPath, v, _oldValue)) {\r\n                                    return;\r\n                                } \r\n\r\n                                bindVariableValue.lastActionMethod = \"SET\";\r\n                                bindVariableValue.lastActionPropertyPath = propertyPath;\r\n\r\n                                component.setProperty(componentProperty, bindVariableValue);\r\n\r\n                                component._callBindVariableAfterPropertyChangedHook(self, componentProperty, propertyPath, v, _oldValue)\r\n\r\n                                bindVariableValue.lastActionMethod = null;\r\n                                bindVariableValue.lastActionPropertyPath = null;\r\n                            }\r\n                        }));\r\n\r\n                    self._callBindVariableAfterChangedHook(obj, observerProperty, _value, _oldValue);\r\n                  }         \r\n            }.bind(self),\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n      }\r\n  }\r\n\r\n  _makeArrayObservable(arr: Array<Object>, observerProperty: string) {\r\n    if (this._registerNewObserver(arr, observerProperty)) {\r\n          arr._emit = function(index: number, items: Object[]) {\r\n              // Use partial rendering only for change or delete operations with 1 element\r\n              if (items.length == 0) this.lastActionMethod = \"DELETE\";\r\n              else if (index == null) this.lastActionMethod = \"ADD\";\r\n              else if (items.length == 1) this.lastActionMethod = \"EDIT\";\r\n              this.lastActionIndex = index ?? this.length - 1;\r\n\r\n              // Notify observers\r\n              this._observers.forEach((properties, component) => properties.forEach(\r\n                  property => component.setProperty(property, this)));\r\n\r\n              // Reset action\r\n              this.lastActionMethod = null;  this.lastActionIndex = null;\r\n\r\n              return this;\r\n          }\r\n          arr.push = function(...items: Object[]) {\r\n              Array.prototype.push.call(this, ...items); arr._emit(null, items); return arr.length;\r\n          };\r\n          arr.splice = function(index: number, deleteCount: number, ...items: Object[]) {\r\n              const deletedItems = Array.prototype.splice.call(this, index, deleteCount, ...items);\r\n              if (deleteCount <= 1)\r\n                arr._emit(index, items);\r\n\r\n            return deletedItems;\r\n          }\r\n          arr.edit = function(index, el) { return this.splice(index, 1, el); };\r\n          arr.delete = function(index) { return this.splice(index, 1); };\r\n      }\r\n  }\r\n\r\n  _registerNewObserver(obj: Object|Array<Object>, observerProperty: string) {\r\n    if (!obj._observers) obj._observers = new Map();\r\n    if (!obj._observers.has(this)) obj._observers.set(this, []);\r\n    if (!obj._observers.get(this).includes(observerProperty)) {\r\n      obj._observers.get(this).push(observerProperty);\r\n      return true;\r\n    }\r\n    else\r\n        return false;\r\n  }\r\n\r\n  _calculateBindings(htmlFunction: string, bindVariableNames: string[]) {\r\n      for (let bindVariableName of bindVariableNames) {\r\n          const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n\r\n          this._allBindExpressions[bindVariableName] = [];\r\n\r\n          for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n              const expr = expression.substring(1);\r\n\r\n              if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                  this._allBindExpressions[bindVariableName].push(expr);\r\n          }\r\n\r\n          this._makeBindVariableObservable(bindVariableName);\r\n      }\r\n  }\r\n\r\n  _renderFull(htmlFunction: TemplateStringFunction, locals: PropertyMap) {\r\n      this._locals = locals;\r\n\r\n      const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n\r\n      const lastExistingElement = this._root.childNodes.length;\r\n\r\n      while(elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n          this._root.appendChild(elements[0]);\r\n\r\n      // Incrementally process only those elements recursively that have not been processed via\r\n      // previous renderList or renderContent method within the same render method, so that the\r\n      // same elements are not processed multiple times and added to the observables data structure.\r\n      for (let index = lastExistingElement; index < this._root.childNodes.length; index++)\r\n          this._processElementBinding(this._root.childNodes[index], bindVariables, bindVariableNames);\r\n  }\r\n\r\n  _renderUpdate(newBindVariableValue: Object) {\r\n      // Only partially update components that render list, since for other components\r\n      // other element would be added/deleted\r\n      if (this._listTemplate != null) {\r\n          this._locals[this._listIt] = this._listData[newBindVariableValue.lastActionIndex];\r\n\r\n          const [elements, bindVariables, bindVariableNames] = this._parseHTML(this._listTemplate, { [this._listIt]: this._listData[newBindVariableValue.lastActionIndex] });\r\n\r\n          if (newBindVariableValue.lastActionMethod == \"ADD\") {\r\n              if (this._root.childNodes[newBindVariableValue.lastActionIndex])\r\n                  this._root.insertBefore(elements[0], this._root.childNodes[this._listStart+newBindVariableValue.lastActionIndex-1].nextSibling);\r\n              else\r\n                  this._root.appendChild(elements[0]);\r\n\r\n              this._processElementBinding(this._root.childNodes[this._listStart+newBindVariableValue.lastActionIndex], bindVariables, bindVariableNames);\r\n          }\r\n          else if (newBindVariableValue.lastActionMethod == \"EDIT\") {\r\n              this._root.replaceChild(elements[0], this._root.childNodes[this._listStart+newBindVariableValue.lastActionIndex])\r\n              this._processElementBinding(this._root.childNodes[this._listStart+newBindVariableValue.lastActionIndex], bindVariables, bindVariableNames);\r\n          }\r\n          else if (newBindVariableValue.lastActionMethod == \"DELETE\")\r\n              this._root.childNodes[this._listStart+newBindVariableValue.lastActionIndex].remove();\r\n      }\r\n  }\r\n\r\n  _makeDerivedVariablesObservable(variableName: string, variableBody: string, html: string) {\r\n    // Nur global in der Form prop: function() bzw. lokal in der Form prop = function()\r\n    // definierte abgeleitete Properties observable machen (keine regul\u00E4ren Methoden / Funktionen\r\n    // in der Form function name() bzw. name())\r\n    if (!this.DERIVED_PROPERTY_SIGNATURE_REGEX.test(variableBody))\r\n         return html;\r\n\r\n     // Make derived bind variables observable\r\n     let referencedBindVariableNames = \"||null\";\r\n     for (const [referencedBindVariableName] of variableBody.matchAll(this.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n         referencedBindVariableNames += \"||\" + referencedBindVariableName;\r\n\r\n      return html.replaceAll(`${variableName}`, `(${variableName}()${referencedBindVariableNames})`);\r\n  }\r\n\r\n  _calculateTemplateAndBindVariableNames(html: string, props: PropertyMap, locals: PropertyMap): [string, string[]] {\r\n      this._renderIteration++;\r\n\r\n      // Determine all binding variables\r\n      const bindVariables = Object.keys(props);\r\n\r\n      // Add additional local variables to binding\r\n      if (locals) {\r\n          for (let [n,v] of Object.entries(locals)) {\r\n              const uniqueBindVariableName = n + this._renderIteration;\r\n\r\n              props[uniqueBindVariableName] = v;\r\n              bindVariables.push(uniqueBindVariableName);\r\n\r\n              const regexp = new RegExp(`(${n.replaceAll(\"$\", \"\\\\$\")})([^=-])`, 'g');\r\n              for (const [expr, , token] of html.matchAll(regexp))\r\n                  html = html.replace(expr, `${uniqueBindVariableName}${token}`);\r\n\r\n              html = this._makeDerivedVariablesObservable(uniqueBindVariableName, v.toString(), html);\r\n          }\r\n      }\r\n\r\n      // Make derived global bind variables observable\r\n      const regexp = new RegExp('(this[\\\\w$.]*\\\\.[\\\\w$]+)([(]?)', 'g');\r\n      for (const [, expr, token] of html.matchAll(regexp)) {\r\n          if (token == '(') continue;\r\n\r\n          // Resolve property variable (defined in componented or referenced from store)\r\n          const index = expr.indexOf(\".\") + 1;\r\n          const functionBody = new Function(\"return \" + expr).call(props).toString().replaceAll(\"this.\", expr.substring(index, expr.indexOf(\".\", index)+1));\r\n\r\n          html = this._makeDerivedVariablesObservable(expr, functionBody, html);   \r\n      }\r\n\r\n      return [html, bindVariables];\r\n  }\r\n\r\n  _processElementBinding(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[]) {\r\n      // Support databinding expressions in attributes (regular DOM elements)\r\n      if (\"attributes\" in element)\r\n          Array.from(element.attributes).forEach((attr: Attr) => {\r\n            if (attr.nodeValue.includes(\"${\"))\r\n                  this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n          });\r\n\r\n      // Support databinding expressions within tags (TextNodes)\r\n      if (\"data\" in element) {\r\n          if (element.data.includes(\"${\"))\r\n              this._processBindingExpression(element, bindVariables, bindVariableNames, \"data\", element.data);\r\n      }\r\n\r\n      // Edit child elements recursively\r\n      if (\"childNodes\" in element)\r\n          for (const childElement of Array.from(element.childNodes)) {\r\n              this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n          }\r\n\r\n      // Render elements with render support      \r\n      if (\"_hasAlreadyRendered\" in element && !element._hasAlreadyRendered())\r\n        element.render();\r\n  }\r\n\r\n  _processBindingExpression(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[], attr: string, expr: string) {\r\n      // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n      const attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);\r\n\r\n      // Save attribute expression for later execution on bind variable changes\r\n      if (!this._observerExpressions.has(element)) this._observerExpressions.set(element, new Map());\r\n      this._observerExpressions.get(element).set(attr, attributeExpression);\r\n\r\n      // Register combination of element and attribute as observer for each bind variable name\r\n      this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames);\r\n\r\n      // Determine current values\r\n      const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n\r\n      // Get current value of element attribute by evaluating expression\r\n      element[attr] = attributeExpression.execute(...bindVariableValues);\r\n  }\r\n\r\n  _buildCallableExpression(attr: string, expr: string, bindVariableNames: string[]) {\r\n      // If expression is the only expression, do not interpret it as string,\r\n      // but evaluate directly so that references to functions can be assigned to properties\r\n      if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length-1)\r\n          expr = \"`\" + expr + \"`\";\r\n      else\r\n          expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n\r\n      let referencedBindVariables = [];\r\n      for (const bindVariableName of bindVariableNames) {\r\n          if (expr.includes(bindVariableName))\r\n              referencedBindVariables.push(bindVariableName);\r\n      }\r\n\r\n      // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n      // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n      // which is not really necessary, but facilitates the generic handling\r\n      return new AttributeExpression(new Function(...referencedBindVariables, \"return \" +  expr).bind(this), referencedBindVariables, expr);\r\n  }\r\n\r\n  _registerElementAttributeAsObserverForBindVariables(element: DOMElement, attr: string, bindVariables: PropertyMap, referencedBindVariableNames: string[]) {\r\n    // Add combination of element and attribute to observer structure\r\n    for (let bindVariableName of referencedBindVariableNames) {\r\n          if (!this._observersForBindVariable.has(bindVariableName)) this._observersForBindVariable.set(bindVariableName, new Map());\r\n\r\n          const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n          if (!variableObservable.has(element)) variableObservable.set(element, []);\r\n\r\n          if (bindVariables[bindVariableName].bind)\r\n              bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // this von Parent an Child mitgeben bei nach unten gereichten Callbacks\r\n\r\n          variableObservable.get(element).push(attr);\r\n      }\r\n  }\r\n\r\n  _getBindVariableValues(bindVariableNames: string[]) {\r\n    let result = [];\r\n    for (const b of bindVariableNames)\r\n        result.push(this._allBindVariables[b]);\r\n\r\n    return result;\r\n  }\r\n\r\n  _updatePropertyObservers(bindVariable: [string, Object]) {\r\n      const [bindVariableName, bindVariableValue] = bindVariable;\r\n\r\n      // Render partially only if element has already been created.\r\n      // (Setters should also be able to be called before component\r\n      // has been created for the first time, which is why state setters\r\n      // only change state here, but have no effect on UI yet).\r\n      if (this._observersForBindVariable.has(bindVariableName)) {\r\n          for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n              for (const attrName of attrs) {\r\n                  const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n                  \r\n                  // Reevaluate binding expression\r\n                  const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                  const newValue = attrExpr.execute(...bindVariableValues);\r\n\r\n                  // Always propagate changes in properties to all observer elements and\r\n                  // propagate changes in subproperties only if subproperty is included in binding expression / template\r\n                  // (e.g. if data.selectedPerson.name is changed, only attributes with bindings to data, data.selectedPerson\r\n                  // and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                  if (!bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                      // Partielle Updates bei Collections triggern\r\n                      if (newValue.lastActionMethod) {\r\n                          if (element instanceof HofHtmlElement)\r\n                            element._renderUpdate(newValue);\r\n                          // console.log(`[${element.tagName ?? \"TEXT\"}] Partial update of ${attrName}: ${newValue.lastActionMethod} ${JSON.stringify(newValue[newValue.lastActionIndex])}`);\r\n                      }\r\n                      else {\r\n                          element[attrName] = newValue;\r\n                          // console.log(`[${element.tagName ?? \"TEXT\"}]: Full update of ${attrName}: ${JSON.stringify(newValue)}`);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n  }\r\n}\r\n\r\n// Helper function to support functional component definition as alternative to class based web component implementation\r\nexport function component(name: string, obj: object, tag = \"div\"): new () => HofHtmlElement {\r\n  let componentConstructor = class extends HofHtmlElement {\r\n      constructor() { super(tag); super.useAutoProps(); }\r\n      render() {}\r\n  };\r\n  componentConstructor[\"componentName\"] = name;\r\n\r\n  for (const prop of Object.keys(obj))\r\n      if (prop == \"render\") {\r\n          const func = obj[prop]();\r\n          const variables = _calculateLocalVariables(prop);\r\n\r\n          delete componentConstructor[\"render\"];\r\n\r\n          if (Array.isArray(func)) {\r\n              const renderFuncs: Function[] = [];\r\n\r\n              if (func.length > 0 && Array.isArray(func[0])) // Array mit Render-Funktionen\r\n                  for (const renderExpr of func)\r\n                      renderFuncs.push(_calculateRenderFunc(renderExpr));\r\n               else\r\n                   renderFuncs.push(_calculateRenderFunc(func));\r\n\r\n              componentConstructor.prototype[\"render\"] = function() { renderFuncs.forEach((renderFunc => renderFunc(this, variables))); }\r\n          }\r\n          else // Call function\r\n              componentConstructor.prototype[\"render\"] = function() { this.renderContent(func, variables); };\r\n      }\r\n      else {\r\n          // Due to a bug in current JS implementations, DOM events are also executed when the getter is\r\n          // accessed, which leads to errors if DOM element / web component is not yet inserted in the\r\n          // real DOM, so that the onXY events are stored here under a different name and later\r\n          // registered within the class under the correct name (this works because the custom element\r\n          // has already been registered than)\r\n          componentConstructor.prototype[\"event-\"+prop] = obj[prop];\r\n      }\r\n\r\n      function _calculateRenderFunc(func: Function|Function[]) {\r\n          if (func.length == 1) // Call [function]\r\n              return function(obj: HofHtmlElement, variables: PropertyMap) { obj.renderContent(func[0], variables); };\r\n          else if (func.length == 2 && typeof(func[0]) == \"function\") // Call [function, variables]\r\n              return function(obj: HofHtmlElement) { obj.renderContent(func[0], func[1]); };\r\n          else if (func.length >= 2 && typeof(func[1]) == \"function\") // Call [listVariable, function, variables]\r\n              return function(obj: HofHtmlElement, variables: PropertyMap) { obj.renderList(obj[func[0]] ?? func[0], func[1], func[2] ?? variables);  }\r\n          else\r\n              throw new Error(\"Invalid render function argument!\");\r\n      }\r\n\r\n      function _calculateLocalVariables(prop: string) {\r\n          let functionDefinition = obj[prop].toString();\r\n          let begin = functionDefinition.indexOf(\"{\") + 1;\r\n          let end = functionDefinition.lastIndexOf(\"return\")\r\n          let functionBody = functionDefinition.substring(begin, end);\r\n\r\n          // Filter out comments\r\n          functionBody = functionBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, ' ');\r\n\r\n          // Calculate variable names\r\n          const regexps = [\r\n            new RegExp(`let[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`const[^\\\\w$]+([\\\\w$]+)[\\\\W]*=`, 'g'),\r\n            new RegExp(`function[^\\\\w$]+([\\\\w$]+)\\\\(`, 'g')\r\n          ];\r\n          const variables = [];\r\n          for (const regexp of regexps)\r\n            for (const [,variable] of functionBody.matchAll(regexp))\r\n                variables.push(variable);\r\n\r\n          // Calculate variable values\r\n          if (variables.length > 0)\r\n            return new Function(functionBody + \"return {\" + variables.join(\",\") + \"}\").call(obj);\r\n          else\r\n            return [];\r\n      }\r\n\r\n  customElements.define(name, componentConstructor);\r\n\r\n  return componentConstructor;\r\n}", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofHtmlElement, component } from '../hof'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofHtmlElement = HofHtmlElement;\r\n(window as any).component = component;"],
  "mappings": "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",
  "names": []
}
