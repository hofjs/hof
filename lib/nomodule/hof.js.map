{
  "version": 3,
  "sources": ["../../src/hof.ts", "../../src/esbuild-wrapper/hof.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\n\r\n// Adapt bind to preserve function body instead of returning [native code] if function is bound which is\r\n// important because _makeDerivedVariablesObservable requires function body to setup observability\r\n(function () {\r\n    const originalBind = Function.prototype.bind;\r\n\r\n    // Only adapt if extension has not already been applied\r\n    if (originalBind.toString().includes(\"[native code]\"))\r\n        Function.prototype.bind = function () {\r\n        const result = originalBind.apply(this, arguments);\r\n        result.toString = () => this.toString();\r\n\r\n        return result;\r\n    }\r\n}());\r\n\r\n// Shim replaceAll if not supported on browser by using a simplified implementation\r\n// that provides all required functionality for this framework\r\n(function() {\r\n    if (!String.prototype.replaceAll) {\r\n        String.prototype.replaceAll = function(find: any, replace: any): string {\r\n            let s = '', index, next;\r\n            while (~(next = this.indexOf(find, index))) {\r\n              s += this.substring(index, next) + replace;\r\n              index = next + find.length;\r\n            }\r\n            return s + this.substring(index);\r\n        };\r\n    }\r\n}());\r\n\r\ninterface PropertyMap {\r\n    [propertyName: string]: Object & Partial<{ bind(thisArg: Object, ...args: Object[]): Object }>\r\n}\r\n\r\ninterface BindVariableExpressionsMap {\r\n    [bindVariableName: string]: string[]\r\n}\r\n\r\ninterface ObjectObservable {\r\n    lastActionMethod: string;\r\n    lastActionIndex: number;\r\n    lastActionObject: Object;\r\n    lastActionPropertyPath: string;\r\n\r\n    _observableUniqueName: string;\r\n    _observers: Map<string, Map<HofHtmlElement, Map<string, string[]>>>;\r\n    _observersPropertyPaths: Map<HofHtmlElement, Map<string, string[]>>;\r\n}\r\n\r\ninterface ArrayObservable<T> extends ObjectObservable { \r\n    _emit: (index: number, items: T[], deletedItems: T[], action: Function) => Array<T>;\r\n\r\n    edit: (index: number, element: T) => T[];\r\n    delete: (index: number) => T[];\r\n}\r\n\r\n// Extend Object and Array<T> within the framework (not global, because extensions \r\n// are only usable within the context of an HofHtmlElement).\r\ntype Object = globalThis.Object & Partial<ObjectObservable>;\r\ntype Array<T> = globalThis.Array<T> & Partial<ArrayObservable<T>>;\r\n\r\ntype DOMElement = HTMLElement | Text | Node | HofHtmlElement;\r\n\r\ntype TemplateStringFunction = (listItemParameter?: Object) => string;\r\n\r\nclass AttributeExpression {\r\n    public constructor(public execute: Function,\r\n        public bindVariableNames: string[], public template: string) {}\r\n}\r\n\r\n// Base class for all Web components created by this framework\r\nexport abstract class HofHtmlElement extends HTMLElement  {\r\n  _tagName: string;\r\n  _root: HTMLElement;\r\n  _shadow: ShadowRoot;\r\n\r\n  _properties: PropertyMap = {}; // Global properties (of component)\r\n  _locals: PropertyMap = {}; // Local variables (of render function), including list iteration variables such as person0, person1, ...\r\n  \r\n  _allBindVariables: PropertyMap = null; // All bind variables, derived from properties and locals\r\n  _allBindExpressions: BindVariableExpressionsMap = {}; // All bind variable expressions used in templates\r\n\r\n  _observersForBindVariable: Map<string, Map<DOMElement, string[]>> = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n  _observerExpressions: Map<DOMElement, Map<string, AttributeExpression>> = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n\r\n  _renderIteration: number = -1; // Each rendering process increments id (rendering of a list of n elements means n incrementations, each update an additional one)\r\n\r\n  _listTemplate: TemplateStringFunction = null;\r\n  _listData: Object[] = [];\r\n  _listIt: string = \"\";\r\n  _listStart: number = 0;\r\n\r\n  PROPS_FILTER = (p: string) => p.charAt(0) != '_' && p != p.toUpperCase() && p != 'constructor' && p != 'render';\r\n  \r\n  REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+)', 'g');\r\n  DERIVED_PROPERTY_FUNCTION_SIGNATURE_REGEX = new RegExp(\"^function[ \\n]*\\\\(\\\\)\");\r\n\r\n  constructor(tagName: string = 'div') {\r\n      super();\r\n      this._tagName = tagName;\r\n      this._shadow = this.attachShadow({ mode: \"open\" });\r\n  }\r\n\r\n  connectedCallback() {\r\n      this._root = document.createElement(this._tagName);\r\n      this._shadow.appendChild(this._root);\r\n\r\n      if (this[\"styles\"]) {\r\n        const styles = document.createElement(\"style\");\r\n        styles.innerHTML = this[\"styles\"];\r\n        this._shadow.appendChild(styles);\r\n      }\r\n\r\n      this.render();\r\n  }\r\n\r\n  abstract render(): void;\r\n\r\n  useAutoProps() {\r\n      // Replace all public simple properties with getters and setters,\r\n      // so that access can be intercepted and observability can be realized\r\n      this._forEachPropertyOfObjectAndPrototype((prop, obj) => {\r\n          const initialValue = obj[prop];\r\n\r\n          // Fix for event handlers because they cannot be added with defineProperty\r\n          // from component() as long as a web component is not part of the DOM\r\n          if (prop.startsWith(\"event-\")) {\r\n              prop = prop.substring(6)\r\n              delete obj[prop];\r\n          }\r\n\r\n          if (prop == \"construct\" && typeof(initialValue) == \"function\")\r\n              initialValue.call(this);\r\n          else if (prop == \"styles\" && typeof(initialValue) == \"function\")\r\n              this[\"styles\"] = initialValue();\r\n          else // Default Property handling\r\n              Object.defineProperty(this, prop, {\r\n                  get: function() { return this.getProperty(prop, initialValue); },\r\n                  set: function(v) {\r\n                      const oldValue = this.getProperty(prop, initialValue);\r\n\r\n                      if (this._callBindVariableBeforeChangedHook(this, prop, v, oldValue)\r\n                        && this._callBindVariableBeforePropertyChangedHook(this, prop, \"\", v, oldValue)) {\r\n                        \r\n                        // If not initial rendering (oldValue != undefined) and value set on\r\n                        // initial rendering is array, make partial update instead of full update\r\n                        if (Array.isArray(oldValue))\r\n                            this._renderUpdate(v);\r\n                        else\r\n                            this.setProperty(prop, v);\r\n\r\n                        this._callBindVariableAfterPropertyChangedHook(this, prop, \"\", v, oldValue);\r\n                        this._callBindVariableAfterChangedHook(this, prop, v, oldValue);\r\n                      }\r\n                    },\r\n                  enumerable: true,\r\n                  configurable: true\r\n              });\r\n      })\r\n  }\r\n\r\n  setProperty(name: string, value: Object) {\r\n      const oldValue = this._properties[name];\r\n\r\n      // Render again in case of complex object or on value change of simple property or on collection action\r\n      if (typeof(oldValue) == \"object\" || typeof(value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n        // Only update property if it was changed and not only subproperty\r\n        if (!value.lastActionPropertyPath) {\r\n          // Process initial element-property setter calls (cache for time after template\r\n          // has been constructed and further binding variables are available)\r\n          this._properties[name] = value;\r\n\r\n          // Update properties including local binding variables\r\n          if (this._allBindVariables)\r\n              this._allBindVariables[name] = value;\r\n\r\n          // Make new objects observable\r\n          if (this._allBindVariables)\r\n              this._makeBindVariableObservable(name);\r\n        }\r\n      }\r\n      \r\n      this._updatePropertyObservers([name, value]);\r\n  }\r\n\r\n  getProperty(name: string, initialValue: Object): Object {\r\n      if (this._allBindVariables)\r\n          return this._allBindVariables[name];\r\n\r\n      return this._properties[name] ?? this.getAttribute(name) as Object ?? initialValue;\r\n  }\r\n\r\n  _hasAlreadyRendered() {\r\n      return this._root.textContent != \"\";\r\n  }\r\n\r\n  renderContent(html: TemplateStringFunction, locals: PropertyMap = undefined) {\r\n      this._renderFull(html, locals);\r\n  }\r\n\r\n  renderList(data: Object[]|string, html: TemplateStringFunction, locals: PropertyMap = undefined) {\r\n      const expression = html.toString();\r\n\r\n      // List parameter has to be identified by =>, because Node returns parameteter without brackets in function.toString()\r\n      // which is important because tests are executed on node\r\n      const listIt = expression.substring(0, expression.indexOf(\"=>\")).replace(\"(\", \"\").replace(\")\", \"\").trim();\r\n\r\n      // List not yet resolved at time of call (first rendering), i.e. still value like ${data}\r\n      if (typeof data == \"string\") return;\r\n\r\n      this._listData = data;\r\n      this._listIt = listIt;\r\n      this._listTemplate = html;\r\n      this._listStart = this._root.childNodes.length;\r\n\r\n      if (typeof(locals) == \"undefined\" || locals == null)\r\n          locals = {};\r\n\r\n      for (const listItem of this._listData) {\r\n          locals[this._listIt] = listItem;\r\n          locals[this._listIt]._observableUniqueName = this._listIt + \"__it\" + (this._renderIteration+1);\r\n\r\n          this._renderFull(html, locals);\r\n      }\r\n  }\r\n\r\n  _calculateProperties() {\r\n      let result = {};\r\n      this._forEachPropertyOfObjectAndPrototype((prop, obj) => result[prop] = obj[prop]);\r\n\r\n      this._allBindVariables = result;\r\n  }\r\n\r\n  _forEachPropertyOfObjectAndPrototype(func: (prop: string, obj: Object) => void) {\r\n      for (const name of Object.getOwnPropertyNames(this).filter(this.PROPS_FILTER))\r\n          func(name, this);\r\n\r\n      const prototype = Object.getPrototypeOf(this);\r\n      for (const name of Object.getOwnPropertyNames(prototype).filter(this.PROPS_FILTER))\r\n          func(name, prototype);\r\n  }\r\n\r\n  _convertToTemplateExpression(buildFunction: TemplateStringFunction) {\r\n      let expression = buildFunction.toString();\r\n      const expressionStart = expression.indexOf('`');\r\n\r\n      if (expressionStart > 0)\r\n          expression = expression.substring(expressionStart+1, expression.length-1);\r\n\r\n      return expression.trim();\r\n  }\r\n\r\n  _parseHTML(htmlFunction: TemplateStringFunction, locals: PropertyMap): [NodeListOf<ChildNode>, PropertyMap, string[]] {\r\n      const html = this._convertToTemplateExpression(htmlFunction);\r\n\r\n      // First call of render?\r\n      if (this._allBindVariables == null)\r\n          this._calculateProperties();\r\n\r\n      const allBindVariables = this._allBindVariables;\r\n      const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n\r\n      this._calculateBindings(template, bindVariableNames);\r\n\r\n      const parser = new DOMParser();\r\n      const elements = parser.parseFromString(template, \"text/html\").body.childNodes;\r\n\r\n      return [elements, allBindVariables, bindVariableNames];\r\n  }\r\n\r\n  _makeBindVariableObservable(bindVariableName: string) {\r\n      for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n          this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n  }\r\n\r\n  _makeBindVariableStructureObservable(bindVariableName: string, bindingExpression: string) {\r\n      const o = this._allBindVariables[bindVariableName];\r\n      const props = bindingExpression.split('.');\r\n\r\n      let propObj = o;\r\n      let propertyPath = bindVariableName;\r\n      for (let i=0; i<props.length; i++) {\r\n          let lastProp = props[i];\r\n          propertyPath += `.${props[i]}`;\r\n\r\n          if (typeof propObj == \"undefined\") return;\r\n\r\n          if (typeof propObj == 'object') {\r\n            if (!Array.isArray(propObj) && propertyPath.includes(\".\") && propObj[lastProp].bind) {\r\n                propObj[lastProp] = propObj[lastProp].bind(propObj);\r\n            }\r\n\r\n              // Do not observe function references\r\n              if (propObj[lastProp][\"bind\"]) continue;\r\n    \r\n              // Observe arrays and objects\r\n              if(!Array.isArray(propObj))\r\n                  this._makeObjectObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n              else {\r\n                  this._makeArrayObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n              }\r\n          }\r\n\r\n          propObj = propObj[props[i]];\r\n      }\r\n  }\r\n\r\n  _callBindVariableBeforeChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}BeforeChanged`;\r\n    if (obj[hookMethodName]) {\r\n        const ret = obj[hookMethodName](newValue, oldValue);\r\n        if (typeof ret != \"undefined\" && ret == false)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _callBindVariableAfterChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}AfterChanged`;\r\n    if (obj[hookMethodName])\r\n        obj[hookMethodName](newValue, oldValue);\r\n  }\r\n\r\n  _callBindVariableBeforePropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}BeforePropertyChanged`;\r\n    if (obj[hookMethodName]) {\r\n        const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n        if (typeof ret != \"undefined\" && ret == false)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _callBindVariableAfterPropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object) {\r\n    const hookMethodName = `${prop}AfterPropertyChanged`;\r\n    if (obj[hookMethodName])\r\n        obj[hookMethodName](subProp, newValue, oldValue);\r\n  }\r\n\r\n  _makeObjectObservable(obj: Object, observerProperty: string, componentProperty: string, propertyPath: string) {\r\n      let _value = obj[observerProperty];\r\n\r\n      const self = this;\r\n\r\n      if (!this._registerNewObserver(obj, observerProperty, this, componentProperty, propertyPath)) {\r\n        Object.defineProperty(obj, observerProperty, {\r\n            get: function() { return _value; }.bind(this),\r\n            set: function(v: Object) {\r\n                const newValue = v;\r\n                const oldValue = obj[observerProperty];\r\n\r\n                self._applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, false, () => _value = v);\r\n            }.bind(this),\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n\r\n        // Adapt binding for methods in properties, so methods use this of surrounding object literal\r\n        if (propertyPath.includes(\".\") && obj[observerProperty].bind) {\r\n            obj[observerProperty] = obj[observerProperty].bind(obj);}\r\n    }\r\n  }\r\n\r\n  _makeArrayObservable(arr: Array<Object>, observerProperty: string, componentProperty: string, propertyPath: string) {\r\n    const self = this;\r\n    if (!this._registerNewObserver(arr, observerProperty, this, componentProperty, propertyPath)) {\r\n          arr._emit = function(index: number, items: Object[], deletedItems: Object[], action: Function) {\r\n            // Use partial rendering only for change or delete operations with 1 element\r\n            if (items.length == 0) this.lastActionMethod = \"DELETE\";\r\n            else if (index == null) this.lastActionMethod = \"ADD\";\r\n            else if (items.length == 1) this.lastActionMethod = \"EDIT\";\r\n\r\n            this.lastActionIndex = index ?? this.length;\r\n\r\n            const newValue = items[items.length - 1];\r\n            const oldValue = deletedItems[deletedItems.length - 1];;\r\n            \r\n            // Return last added, updated or deleted element\r\n            this.lastActionObject = newValue ?? oldValue;\r\n\r\n            self._applyValueAndNotifyObservers(this, observerProperty, componentProperty, newValue, oldValue, true, action);\r\n\r\n            // Reset action\r\n            this.lastActionMethod = null;  this.lastActionIndex = null; this.lastActionObject = null; this.lastActionPropertyPath = null;\r\n\r\n            return this;\r\n          }\r\n          arr.push = function(...items: Object[]) {       \r\n              arr._emit(null, items, [], () =>  Array.prototype.push.call(this, ...items));\r\n              \r\n              return arr.length;\r\n          };\r\n          arr.splice = function(index: number, deleteCount: number, ...items: Object[]) {\r\n              const deletedItems = this.slice(index, index + deleteCount);\r\n              if (deleteCount <= 1)\r\n                arr._emit(index, items, deletedItems, () => Array.prototype.splice.call(this, index, deleteCount, ...items));\r\n\r\n            return deletedItems;\r\n          }\r\n          arr.edit = function(index, el) { return this.splice(index, 1, el); };\r\n          arr.delete = function(index) { return this.splice(index, 1); };\r\n      }\r\n  }\r\n\r\n  _applyValueAndNotifyObservers(obj: Object, observerProperty: string, componentProperty: string, newValue: Object, oldValue: object, arrayNotification: boolean, action: Function) {\r\n    const self = this;\r\n\r\n    if (!self._callBindVariableBeforeChangedHook(self, componentProperty, self[componentProperty], self[componentProperty])\r\n        || !self._callBindVariableBeforePropertyChangedHook(self, componentProperty, observerProperty, newValue, oldValue))\r\n        return;\r\n\r\n    action();\r\n\r\n    obj._observers.get(observerProperty).forEach((componentDetails, component) => {\r\n        componentDetails.forEach((componentPropertyPaths, componentProperty) => {\r\n            componentPropertyPaths.forEach(componentPropertyPath => {\r\n                // On arrays if length property is changed, array ist changed, so adapt\r\n                // property path to match expressions depending on array instead of array.length property\r\n                if (arrayNotification)\r\n                    componentPropertyPath = componentPropertyPath.replace(\".length\", \"\");\r\n\r\n                let bindVariableValue = component.getProperty(componentProperty, undefined);\r\n                if (bindVariableValue) {\r\n                    if (!arrayNotification) bindVariableValue.lastActionMethod = \"SET\";\r\n\r\n                    if (!component._callBindVariableBeforeChangedHook(component, componentProperty, component[componentProperty], component[componentProperty])\r\n                        || !component._callBindVariableBeforePropertyChangedHook(component, componentProperty, componentPropertyPath, newValue, oldValue)) {\r\n                        return;\r\n                    }\r\n\r\n                    bindVariableValue.lastActionPropertyPath = componentPropertyPath;                                    \r\n                    component.setProperty(componentProperty, bindVariableValue);\r\n\r\n                    component._callBindVariableAfterPropertyChangedHook(self, componentProperty, componentPropertyPath, newValue, oldValue)                          \r\n\r\n                    bindVariableValue.lastActionMethod = null;\r\n                    bindVariableValue.lastActionPropertyPath = null;\r\n                }\r\n            });\r\n        });                                    \r\n    });\r\n\r\n    self._callBindVariableAfterChangedHook(self, componentProperty, self[componentProperty], self[componentProperty]);\r\n  }\r\n\r\n  _registerNewObserver(obj: Object|Array<Object>, observerProperty: string, component: HofHtmlElement, componentProperty: string, componentPropertyPath: string) {\r\n    let propertyAlreadyObserved = true; \r\n    if (!obj._observers) obj._observers = new Map();\r\n    if (!obj._observers.has(observerProperty)) {\r\n        obj._observers.set(observerProperty, new Map());\r\n        propertyAlreadyObserved = false;\r\n    }\r\n    if (!obj._observers.get(observerProperty).has(component)) obj._observers.get(observerProperty).set(component, new Map());\r\n    if (!obj._observers.get(observerProperty).get(component).has(componentProperty)) obj._observers.get(observerProperty).get(component).set(componentProperty, []);\r\n\r\n    const objObserverList = obj._observers.get(observerProperty).get(component).get(componentProperty);\r\n    if (!objObserverList.includes(componentPropertyPath))\r\n       objObserverList.push(componentPropertyPath);\r\n\r\n    return propertyAlreadyObserved;\r\n  }\r\n\r\n  _calculateBindings(htmlFunction: string, bindVariableNames: string[]) {\r\n      for (let bindVariableName of bindVariableNames) {\r\n          const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n\r\n          this._allBindExpressions[bindVariableName] = [];\r\n\r\n          for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n              const expr = expression.substring(1);\r\n\r\n              if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                  this._allBindExpressions[bindVariableName].push(expr);\r\n          }\r\n\r\n          this._makeBindVariableObservable(bindVariableName);\r\n      }\r\n  }\r\n\r\n  _renderFull(htmlFunction: TemplateStringFunction, locals: PropertyMap) {\r\n      this._locals = locals;\r\n\r\n      const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n\r\n      const lastExistingElement = this._root.childNodes.length;\r\n\r\n      while(elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n          this._root.appendChild(elements[0]);\r\n\r\n      // Incrementally process only those elements recursively that have not been processed via\r\n      // previous renderList or renderContent method within the same render method, so that the\r\n      // same elements are not processed multiple times and added to the observables data structure.\r\n      for (let index = lastExistingElement; index < this._root.childNodes.length; index++)\r\n          this._processElementBinding(this._root.childNodes[index], bindVariables, bindVariableNames);\r\n  }\r\n\r\n  _removeObserversForBindVariable(bindVariableToDelete: string) {\r\n      // Remove observer expressions\r\n      if (this._observersForBindVariable.has(bindVariableToDelete))\r\n        for (const [comp] of this._observersForBindVariable.get(bindVariableToDelete)) {\r\n            for (const [attr, expr] of this._observerExpressions.get(comp)) {\r\n                if (expr.bindVariableNames.includes(bindVariableToDelete))\r\n                    this._observerExpressions.get(comp).delete(attr);                \r\n            }\r\n\r\n            if (this._observerExpressions.get(comp).size == 0)\r\n                this._observerExpressions.delete(comp);\r\n        }\r\n\r\n        // Remove observers for bind variable\r\n        this._observersForBindVariable.delete(bindVariableToDelete);\r\n \r\n        // Remove bind variable\r\n        delete this._allBindVariables[bindVariableToDelete];\r\n\r\n        // Remove all bind expressions for bind variable\r\n        delete this._allBindExpressions[bindVariableToDelete];\r\n  }\r\n\r\n  _renderUpdate(value: Object) {\r\n      // Only partially update components that render list, since for other components\r\n      // other element would be added/deleted\r\n      if (this._listTemplate != null) {\r\n          this._locals[this._listIt] = this._listData[value.lastActionIndex];\r\n\r\n          // Remove node\r\n          if (value.lastActionMethod == \"DELETE\") {\r\n            this._removeObserversForBindVariable(value.lastActionObject._observableUniqueName);\r\n            this._root.childNodes[this._listStart+value.lastActionIndex].remove();\r\n          }\r\n          else {\r\n            this._locals[this._listIt]._observableUniqueName = this._listIt + \"__it\" + (this._renderIteration+1);\r\n\r\n            // Parse new html for added or updated content\r\n            const [elements, bindVariables, bindVariableNames] = this._parseHTML(this._listTemplate, this._locals);\r\n\r\n            // Add or replace html\r\n            if (value.lastActionMethod == \"ADD\") {\r\n                if (this._root.childNodes[value.lastActionIndex])\r\n                    this._root.insertBefore(elements[0], this._root.childNodes[this._listStart+value.lastActionIndex-1].nextSibling);\r\n                else\r\n                    this._root.appendChild(elements[0]);\r\n\r\n                this._processElementBinding(this._root.childNodes[this._listStart+value.lastActionIndex], bindVariables, bindVariableNames);\r\n            }\r\n            else if (value.lastActionMethod == \"EDIT\") {\r\n\r\n                this._root.replaceChild(elements[0], this._root.childNodes[this._listStart+value.lastActionIndex])\r\n                this._processElementBinding(this._root.childNodes[this._listStart+value.lastActionIndex], bindVariables, bindVariableNames);\r\n            }\r\n        }\r\n      }\r\n  }\r\n\r\n  _logUpdate(element: DOMElement, name: string, value: Object) {\r\n      // Filter out function references on first rendering because they are not observed\r\n      if (value[\"bind\"]) return;\r\n\r\n      // If property path is specified, component is not updated, but child component that references property path\r\n      if (value.lastActionPropertyPath) return;\r\n     \r\n      console.log(`[${element.nodeName ?? \"TEXT\"}]: Update of ${name}: ${value.lastActionMethod ?? \"SET\"} ${JSON.stringify(value.lastActionObject ?? value)}`);\r\n  }\r\n\r\n  _makeDerivedVariablesObservable(variableName: string, variableBody: string, html: string) {\r\n    // Make only globally in the form prop: function() or locally in the form prop = function() defined derived properties\r\n    // observable (local lambda expressions are also supported because they get transformed into prop = function())\r\n    if (!this.DERIVED_PROPERTY_FUNCTION_SIGNATURE_REGEX.test(variableBody))\r\n         return html;\r\n\r\n     // Make derived bind variables observable\r\n    let referencedBindVariableNames = \"||null\";\r\n    for (const [referencedBindVariableName] of variableBody.matchAll(this.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n        referencedBindVariableNames += \"||\" + referencedBindVariableName;\r\n\r\n    return html.replace(new RegExp(`([^\\\\w])${variableName}\\\\(\\\\)([^\\\\w])`, \"g\"), `$1(${variableName}()${referencedBindVariableNames})$2`);\r\n  }\r\n\r\n  _calculateUniqueElementAndVariableName(name: string, renderIteration: number) {\r\n      return name + \"__it\" + renderIteration;\r\n  }\r\n\r\n  _calculateTemplateAndBindVariableNames(html: string, props: PropertyMap, locals: PropertyMap): [string, string[]] {\r\n      this._renderIteration++;\r\n\r\n      // Determine all binding variables\r\n      const bindVariables = Object.keys(props);\r\n\r\n      // Add additional local variables to binding\r\n      if (locals) {\r\n          for (let [variableName, variableValue] of Object.entries(locals)) {\r\n              const uniqueBindVariableName = variableName + \"__it\" + this._renderIteration;\r\n\r\n              props[uniqueBindVariableName] = variableValue;\r\n              bindVariables.push(uniqueBindVariableName);\r\n\r\n              // Replace variable name with unique name to support list parameters\r\n              html = html.replace(new RegExp(`([{][^{}]*[^\\\\w]?)${variableName}([^\\\\w])`, \"g\"), `$1${uniqueBindVariableName}$2`);\r\n              \r\n              html = this._makeDerivedVariablesObservable(uniqueBindVariableName, variableValue.toString(), html);\r\n          }\r\n      }\r\n\r\n      // Make derived global bind variables observable\r\n      const regexp = new RegExp('(this[\\\\w$.]*\\\\.[\\\\w$]+)([(]?)', 'g');\r\n      for (const [, expr] of html.matchAll(regexp)) {\r\n          // Resolve property variable (defined in component or referenced from store)\r\n          const index = expr.indexOf(\".\") + 1;\r\n          const func = new Function(\"return \" + expr).call(props);\r\n          if (!func) continue;\r\n\r\n          const functionBody = func.toString().replaceAll(\"this.\", expr.substring(index, expr.indexOf(\".\", index)+1));\r\n\r\n          html = this._makeDerivedVariablesObservable(expr, functionBody, html);\r\n      }\r\n\r\n      return [html, bindVariables];\r\n  }\r\n\r\n  _processElementBinding(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[]) {\r\n      // Support databinding expressions in attributes (regular DOM elements)\r\n      if (\"attributes\" in element)\r\n          Array.from(element.attributes).forEach((attr: Attr) => {\r\n            if (attr.nodeValue.includes(\"${\"))\r\n                  this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n          });\r\n\r\n      // Support databinding expressions within tags (TextNodes)\r\n      if (\"data\" in element) {\r\n          if (element.data.includes(\"${\"))\r\n              this._processBindingExpression(element, bindVariables, bindVariableNames, \"data\", element.data);\r\n      }\r\n\r\n      // Edit child elements recursively\r\n      if (\"childNodes\" in element)\r\n          for (const childElement of Array.from(element.childNodes)) {\r\n              this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n          }\r\n\r\n      // Render elements with render support      \r\n      if (\"_hasAlreadyRendered\" in element && !element._hasAlreadyRendered())\r\n        element.render();\r\n  }\r\n\r\n  _processBindingExpression(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[], attr: string, expr: string) {\r\n      // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n      const attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);      \r\n\r\n      // Save attribute expression for later execution on bind variable changes\r\n      if (!this._observerExpressions.has(element)) this._observerExpressions.set(element, new Map());\r\n      this._observerExpressions.get(element).set(attr, attributeExpression);\r\n\r\n      // Rebind this of subproperties to parent property\r\n      for (let bindVariableName of attributeExpression.bindVariableNames) {\r\n        if (bindVariables[bindVariableName].bind)\r\n            bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n      }\r\n\r\n      // Determine current values\r\n      const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n\r\n      // Get current value of element attribute by evaluating expression\r\n      const value = attributeExpression.execute(...bindVariableValues);\r\n\r\n      element[attr] = value;\r\n      \r\n      // Register combination of element and attribute as observer for each bind variable name\r\n      if (value != null && !value[\"bind\"]) // Do not observe functions\r\n        this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames); \r\n  }\r\n\r\n  _buildCallableExpression(attr: string, expr: string, bindVariableNames: string[]) {\r\n      // If expression is the only expression, do not interpret it as string,\r\n      // but evaluate directly so that references to functions can be assigned to properties\r\n      if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length-1)\r\n          expr = \"`\" + expr + \"`\";\r\n      else\r\n          expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n\r\n      let referencedBindVariables = [];\r\n      for (const bindVariableName of bindVariableNames) {\r\n          if (expr.includes(bindVariableName))\r\n              referencedBindVariables.push(bindVariableName);\r\n      }\r\n\r\n      // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n      // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n      // which is not really necessary, but facilitates the generic handling (errors as a consequence of expressions\r\n      // that are not resolved yet, are catched to support functions on properties such as persons.map)\r\n      return new AttributeExpression(new Function(...referencedBindVariables, \"try {return \" +  expr + \"} catch(e) { return ''; }\").bind(this), referencedBindVariables, expr);\r\n  }\r\n\r\n  _registerElementAttributeAsObserverForBindVariables(element: DOMElement, attr: string, bindVariables: PropertyMap, referencedBindVariableNames: string[]) {\r\n    // Add combination of element and attribute to observer structure\r\n    for (let bindVariableName of referencedBindVariableNames) {\r\n          if (!this._observersForBindVariable.has(bindVariableName)) this._observersForBindVariable.set(bindVariableName, new Map());\r\n\r\n          const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n          if (!variableObservable.has(element)) variableObservable.set(element, []);\r\n\r\n          if (bindVariables[bindVariableName].bind)\r\n              bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n\r\n          variableObservable.get(element).push(attr);\r\n      }\r\n  }\r\n\r\n  _getBindVariableValues(bindVariableNames: string[]) {\r\n    let result = [];\r\n    for (const b of bindVariableNames)\r\n        result.push(this._allBindVariables[b]);\r\n\r\n    return result;\r\n  }\r\n\r\n  _updatePropertyObservers(bindVariable: [string, Object]) {\r\n      const [bindVariableName, bindVariableValue] = bindVariable;\r\n\r\n      // Render partially only if element has already been created.\r\n      // (Setters should also be able to be called before component\r\n      // has been created for the first time, which is why state setters\r\n      // only change state here, but have no effect on UI yet).\r\n      if (this._observersForBindVariable.has(bindVariableName)) {\r\n          for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n              for (const attrName of attrs) {\r\n                  const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n\r\n                  if (!bindVariableValue.lastActionPropertyPath || attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                    // Reevaluate binding expression\r\n                    const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                    const newValue = attrExpr.execute(...bindVariableValues);\r\n\r\n                    // Always propagate changes in properties to all observer elements and\r\n                    // propagate changes in subproperties only if subproperty is included in binding expression / template\r\n                    // (e.g. if data.selectedPerson.name is changed, only attributes with bindings to data, data.selectedPerson\r\n                    // and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                    if (typeof newValue.lastActionIndex != \"undefined\" || !bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                        // Always update HofHTMLElement to pass down subproperty changes to sub components,\r\n                        // but update simple html elements only if value changed\r\n                        if (element instanceof HofHtmlElement || element[attrName] != newValue) {\r\n                            // this._logUpdate(element, attrName, newValue);\r\n\r\n                            element[attrName] = newValue;\r\n                        }\r\n                    }\r\n                }\r\n              }\r\n          }\r\n      }\r\n  }\r\n}\r\n\r\ntype BeforeChangedHookName<PropertyName extends string> = `${PropertyName}BeforeChanged`;\r\ntype BeforeChangedHookType<PropertyType> = (newValue: PropertyType, oldValue: PropertyType) => boolean;\r\ntype AfterChangedHookName<PropertyName extends string> = `${PropertyName}AfterChanged`;\r\ntype AfterChangedHookType<PropertyType> = (newValue: PropertyType, oldValue: PropertyType) => void;\r\ntype BeforePropertyChangedHookName<PropertyName extends string> = `${PropertyName}BeforePropertyChanged`;\r\ntype BeforePropertyChangedHookType<PropertyType> = (subProp: string, newValue: PropertyType, oldValue: PropertyType) => boolean;\r\ntype AfterPropertyChangedHookName<PropertyName extends string> = `${PropertyName}AfterPropertyChanged`;\r\ntype AfterPropertyChangedHookType<PropertyType> = (subProp: string, newValue: PropertyType, oldValue: PropertyType) => void;\r\n\r\ntype HofHtmlElementComponentLiteralWithHooks<HofHtmlElementComponentLiteral> = {\r\n    [Propertyname in keyof HofHtmlElementComponentLiteral]: Object;\r\n} & {\r\n    [PropertyName in BeforeChangedHookName<string & keyof HofHtmlElementComponentLiteral>]?:\r\n        BeforeChangedHookType<HofHtmlElementComponentLiteral[string & keyof HofHtmlElementComponentLiteral]>;\r\n} & {\r\n    [PropertyName in AfterChangedHookName<string & keyof HofHtmlElementComponentLiteral>]?:\r\n        AfterChangedHookType<HofHtmlElementComponentLiteral[string & keyof HofHtmlElementComponentLiteral]>;\r\n} & {\r\n    [PropertyName in BeforePropertyChangedHookName<string & keyof HofHtmlElementComponentLiteral>]?:\r\n        BeforePropertyChangedHookType<HofHtmlElementComponentLiteral[string & keyof HofHtmlElementComponentLiteral]>;\r\n} & {\r\n    [PropertyName in AfterPropertyChangedHookName<string & keyof HofHtmlElementComponentLiteral>]?:\r\n        AfterPropertyChangedHookType<HofHtmlElementComponentLiteral[string & keyof HofHtmlElementComponentLiteral]>;\r\n} & {\r\n    construct?: Function;\r\n    render: Function;\r\n}\r\n\r\n// Helper function to support functional component definition as alternative to class based web component implementation\r\nexport function component<T extends HofHtmlElementComponentLiteralWithHooks<T>>(name: string, obj: T, tag = \"div\"): new () => HofHtmlElement & T {\r\n  let componentConstructor = class extends HofHtmlElement {\r\n      constructor() { super(tag); super.useAutoProps(); }\r\n      render() {}\r\n  };\r\n  componentConstructor[\"componentName\"] = name;\r\n\r\n  for (const prop of Object.keys(obj))\r\n      if (prop == \"render\") {\r\n          const func = obj[prop]();\r\n          const variables = _calculateLocalVariables(prop);\r\n\r\n          delete componentConstructor[\"render\"];\r\n\r\n          if (Array.isArray(func)) {\r\n              const renderFuncs: Function[] = [];\r\n\r\n              if (func.length > 0 && Array.isArray(func[0])) // Array with render function\r\n                  for (const renderExpr of func)\r\n                      renderFuncs.push(_calculateRenderFunc(renderExpr));\r\n               else\r\n                   renderFuncs.push(_calculateRenderFunc(func));\r\n\r\n              componentConstructor.prototype[\"render\"] = function() { renderFuncs.forEach((renderFunc => renderFunc(this, variables))); }\r\n          }\r\n          else // Call function\r\n              componentConstructor.prototype[\"render\"] = function() { this.renderContent(func, variables); };\r\n      }\r\n      else {\r\n          // Due to a bug in current JS implementations, DOM events are also executed when the getter is\r\n          // accessed, which leads to errors if DOM element / web component is not yet inserted in the\r\n          // real DOM, so that the onXY events are stored here under a different name and later\r\n          // registered within the class under the correct name (this works because the custom element\r\n          // has already been registered than)\r\n          componentConstructor.prototype[\"event-\"+prop] = obj[prop];\r\n      }\r\n\r\n      function _calculateRenderFunc(func: Function|Function[]) {\r\n          if (func.length == 1) // Call [function]\r\n              return function(obj: HofHtmlElement, variables: PropertyMap) { obj.renderContent(func[0], variables); };\r\n          else if (func.length == 2 && typeof(func[0]) == \"function\") // Call [function, variables]\r\n              return function(obj: HofHtmlElement) { obj.renderContent(func[0], func[1]); };\r\n          else if (func.length >= 2 && typeof(func[1]) == \"function\") // Call [listVariable, function, variables]\r\n              return function(obj: HofHtmlElement, variables: PropertyMap) { obj.renderList(obj[func[0]] ?? func[0], func[1], func[2] ?? variables);  }\r\n          else\r\n              throw new Error(\"Invalid render function argument!\");\r\n      }\r\n\r\n      function _calculateLocalVariables(prop: string) {\r\n          let functionDefinition = obj[prop].toString();\r\n          \r\n          // Filter out comments (this has to be done before looking for return statement to avoid return within comment to be returned)\r\n          functionDefinition = functionDefinition.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm, ' ');\r\n\r\n          let begin = functionDefinition.indexOf(\"{\") + 1;\r\n          let end = functionDefinition.lastIndexOf(\"return\")\r\n          let functionBody = functionDefinition.substring(begin, end);\r\n\r\n          // Replace lambda expressions with scoped functions to\r\n          // enable rebind of this (because this must reference component\r\n          // instead of component literal to make observability work)\r\n          functionBody = functionBody.replace(/[ \\n]+=[ \\n]+\\(([^\\)]*)\\)[ \\n]*=>[ \\n]*({[ \\n]*return)?([^;]+;[ \\n]*)}?/gm, \"= function($1) { return $3 }; \");\r\n\r\n          // Calculate variable names\r\n          const variables = [];\r\n            for (const [,,variable] of functionBody.matchAll(/(const|let|function)[ \\n]+([^ \\n(=]+)/gm))\r\n                variables.push(variable);\r\n\r\n          // Calculate variable values\r\n          if (variables.length > 0)\r\n            return new Function(functionBody + \"return {\" + variables.join(\",\") + \"}\").call(obj);\r\n          else\r\n            return [];\r\n      }\r\n\r\n  customElements.define(name, componentConstructor);\r\n\r\n  return componentConstructor as new() => HofHtmlElement & T;\r\n}", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofHtmlElement, component } from '../hof'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofHtmlElement = HofHtmlElement;\r\n(window as any).component = component;"],
  "mappings": "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",
  "names": []
}
